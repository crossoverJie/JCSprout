# 对锁的一些认知 有哪些锁

## 同一进程

### [重入锁](https://github.com/crossoverJie/Java-Interview/blob/master/MD/ReentrantLock.md)
使用 `ReentrantLock` 获取锁的时候会判断当前线程是否为获取锁的线程，如果是则将同步的状态 +1 ,释放锁的时候则将状态 -1。只有将同步状态的次数置为 0 的时候才会最终释放锁。

### 读写锁
使用 `ReentrantReadWriteLock` ,同时维护一对锁：读锁和写锁。遵循如下规则：

1. 写线程占有资源进行操作时则其他所有锁（读和写）都将阻塞。
2. 读线程占有资源进行操作时，读操作不阻塞，写操作会阻塞。

通过读写锁的分离可以很大程度的提高并发量和吞吐量。


## 不同进程

不同进程中的锁为`分布式锁`，其实现机制可以有如下几种。

### 基于数据库
可以创建一张表，将其中的某个字段设置为`唯一索引`，当多个请求过来的时候只有新建记录成功的请求才算获取到锁，当使用完毕删除这条记录的时候即释放锁。

存在的问题:
- 数据库单点问题，挂了怎么办？
- 不是重入锁，同一进程无法在释放锁之前再次获得锁，因为数据库中已经存在了一条记录了。
- 锁是非阻塞的，一旦 `insert` 失败则会立即返回，并不会进入阻塞队列只能下一次再次获取。
- 锁没有失效时间，如果那个进程解锁失败那就没有请求可以再次获取锁了。

解决方案:
- 数据库切换为主从，不存在单点。
- 在表中加入一个同步状态字段，每次获取锁的是加 1 ，释放锁的时候`-1`，当状态为 0 的时候就删除这条记录，即释放锁。
- 非阻塞的情况可以用 `while` 循环来实现，循环的时候记录时间，达到 X 秒记为超时，`break`。
- 可以开启一个定时任务每隔一段时间扫描找出多少 X 秒都没有被删除的记录，主动删除这条记录。

### 基于 Redis

使用 `setNX(key) setEX(timeout)` 命令，只有在该 `key` 不存在的时候创建这个 `key`，就相当于获取了锁。由于有超时时间，所以过了规定时间会自动删除，这样也可以避免死锁。

可以参考：

[基于 Redis 的分布式锁](http://crossoverjie.top/2018/03/29/distributed-lock/distributed-lock-redis/)

存在问题：

- 为了避免死锁，设置了超时时间，如果恰恰某个业务的执行时间超过了超时时间，那么会导致分布式锁被错误释放。
- Redis做`Master-Slave`集群的时候，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。

解决方案:

- 获取到分布式锁的时候，添加一个随机的value，当删除的时候，判定当前锁的value同自身保存的value是否相同，如果不同说明当前进程超时了，通过抛出错误，引入人工处理。
- 通过`RedLock算法`进行处理！

### 基于 ZK

ZK的发布就是为了分布式锁，所以如果要用非常严格的分布式锁，那么推荐使用ZK。

ZK能够很好的避免上述的问题，应该算是最严格的分布式锁方案之一了！

- ZK可以集群来避免单点问题，同时ZK时满足的CAP原则中的CP，所以不会出现Redis中的`RedLock`问题。
- ZK的客户端会通过心跳来同ZK进行保持连接，客户端宕机，临时的锁节点会自动消失。

参考链接：[Zookeeper分布式锁](https://juejin.im/post/5b8795d3e51d453894003c55)

> 严格意味着性能损失和消耗大，所以需要结合业务粒度进行选择。